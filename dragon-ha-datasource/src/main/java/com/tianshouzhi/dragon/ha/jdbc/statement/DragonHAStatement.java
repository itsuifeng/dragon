package com.tianshouzhi.dragon.ha.jdbc.statement;

import com.tianshouzhi.dragon.common.WrapperAdapter;
import com.tianshouzhi.dragon.common.exception.ExceptionSorter;
import com.tianshouzhi.dragon.ha.dbselector.DBIndex;
import com.tianshouzhi.dragon.ha.dbselector.DatasourceWrapper;
import com.tianshouzhi.dragon.ha.jdbc.connection.DragonHAConnection;
import com.tianshouzhi.dragon.ha.jdbc.connection.HAConnectionManager;
import com.tianshouzhi.dragon.ha.sqltype.SqlTypeUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static com.tianshouzhi.dragon.ha.jdbc.statement.DragonHAStatement.CreateType.NONE;
import static com.tianshouzhi.dragon.ha.jdbc.statement.DragonHAStatement.CreateType.RESULTSET_TYPE_CONCURRENCY;
import static com.tianshouzhi.dragon.ha.jdbc.statement.DragonHAStatement.CreateType.RESULTSET_TYPE_CONCURRENCY_HOLDABILITY;
import static com.tianshouzhi.dragon.ha.jdbc.statement.DragonHAStatement.ExecuteType.*;

/**
 * Created by TIANSHOUZHI336 on 2016/12/3.
 */
public class DragonHAStatement extends WrapperAdapter implements Statement {
    private static final Logger LOGGER= LoggerFactory.getLogger(DragonHAStatement.class);
    protected DragonHAConnection dragonHAConnection;
    protected Statement realStatement;
    private Lock batchLock=new ReentrantLock();
    //Statement构造创建参数
    protected Integer resultSetType;
    protected Integer resultSetConcurrency;
    protected Integer resultSetHoldability;

    //Statement属性参数，执行前进行设置
    private Integer queryTimeout;
    private Integer fetchDirection;
    private Integer fetchSize;
    private Boolean poolable;
    private Integer maxRows;
    private Integer maxFieldSize;
    private Boolean enableEscapeProcessing;

    protected  String sql;
    protected Integer autoGeneratedKeys;
    protected int[] columnIndexes;
    protected String[] columnNames;
    //Statement状态参数，用户主动调用api设置
    private boolean isClosed = false;

    //Statement查询执行结果
    protected ResultSet resultSet;
    //Statement更新执行结果
    protected ResultSet generatedKeys;
    protected int updateCount = 0;
    protected  int[] batchExecuteResult;

    protected ExecuteType executeType=null;
    protected CreateType createType=null;
    protected  enum ExecuteType{
        EXECUTE_QUERY, EXECUTE_UPDATE, EXECUTE, EXECUTE_UPDATE_WITH_AUTOGENERATEDKEYS, EXECUTE_UPDATE_WITH_COLUMNINDEXES, EXECUTE_WITH_AUTOGENERATEDKEYS, EXECUTE_WITH_COLUMNINDEXES, EXECUTE_WITH_COLUMNNAMES, EXECUTE_BATCH, EXECUTE_UPDATE_WITH_COLUMNNAMES
    }
    protected enum CreateType{
        NONE,RESULTSET_TYPE_CONCURRENCY,RESULTSET_TYPE_CONCURRENCY_HOLDABILITY
    }

    public DragonHAStatement(DragonHAConnection dragonHAConnection) {
        this.dragonHAConnection=dragonHAConnection;
        this.createType=NONE;
    }

    public DragonHAStatement(Integer resultSetType, Integer resultSetConcurrency, DragonHAConnection dragonHAConnection) {
        this.dragonHAConnection=dragonHAConnection;
        this.resultSetType=resultSetType;
        this.resultSetConcurrency=resultSetConcurrency;
        this.createType=RESULTSET_TYPE_CONCURRENCY;
    }

    public DragonHAStatement(Integer resultSetType, Integer resultSetConcurrency, Integer resultSetHoldability, DragonHAConnection dragonHAConnection) {
        this.dragonHAConnection = dragonHAConnection;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = resultSetHoldability;
        this.createType=RESULTSET_TYPE_CONCURRENCY_HOLDABILITY;
    }

    protected void createRealStatement(Connection realConnection) throws SQLException {
        switch (createType) {
            case NONE:
                realStatement = realConnection.createStatement();
                break;
            case RESULTSET_TYPE_CONCURRENCY:
                realStatement = realConnection.createStatement(resultSetType, resultSetConcurrency);
                break;
            case RESULTSET_TYPE_CONCURRENCY_HOLDABILITY:
                realStatement = realConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
                break;
        }
       setStatementParams();
    }

    //=======================显示指定进行查询==================
    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        this.sql=sql;
        executeType= EXECUTE_QUERY;
        doExecute();
        return resultSet;
    }

   //===================显示指定进行更新 =======================
    @Override
    public int executeUpdate(String sql) throws SQLException {
        this.sql=sql;
        this.executeType=ExecuteType.EXECUTE_UPDATE;
        doExecute();
        return updateCount;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        this.sql=sql;
        this.autoGeneratedKeys=autoGeneratedKeys;
        this.executeType=ExecuteType.EXECUTE_UPDATE_WITH_AUTOGENERATEDKEYS;
        doExecute();
        return updateCount;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        this.sql=sql;
        this.columnIndexes=columnIndexes;
        this.executeType=ExecuteType.EXECUTE_UPDATE_WITH_COLUMNINDEXES;
        doExecute();
        return updateCount;
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        this.sql=sql;
        this.columnNames=columnNames;
        this.executeType=ExecuteType.EXECUTE_UPDATE_WITH_COLUMNNAMES;
        doExecute();
        return updateCount;
    }

    //=================不指定sql是查询还是更新，程序自动判断========================
    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        this.sql=sql;
        this.autoGeneratedKeys=autoGeneratedKeys;
        this.executeType=ExecuteType.EXECUTE_WITH_AUTOGENERATEDKEYS;
        return doExecute();
    }
    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        this.sql=sql;
        this.columnIndexes=columnIndexes;
        this.executeType=ExecuteType.EXECUTE_WITH_COLUMNINDEXES;
        return doExecute();
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        this.sql=sql;
        this.columnNames=columnNames;
        this.executeType=ExecuteType.EXECUTE_WITH_COLUMNNAMES;
        return doExecute();
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        this.sql=sql;
        this.executeType= EXECUTE;
        return doExecute();
    }

    //只有单条sql的时候，应该调用这个方法，batch和callablestatemnt自行处理
    public boolean doExecute() throws SQLException {
        if(resultSet!=null){//jdbc规范规定，每次执行的时候，如果当前ResultSet不为空，需要显示关闭，因此最好一个Statement执行一个sql
            resultSet.close();
        }
        int errorCount = 0;
        boolean isResultSet = false;
        int maxRetryTimes = 3;
        Set<DBIndex> excludes = null;
        for (int i = 0; i < maxRetryTimes; i++) {
            Connection realConnection=null;
            try {
                if(executeType!=EXECUTE_BATCH){
                     realConnection = dragonHAConnection.getRealConnection(sql,useSqlTypeCache());
                }else{//批处理操作，没有sql可以判断
                    realConnection= dragonHAConnection.changeToWtiteConnectionIfNeed();
                }
                createRealStatement(realConnection);
                isResultSet = doExecuteByType();
                //正常执行完成，跳出循环，不进行重试
                setExecuteResult();
                return isResultSet;
            } catch (SQLException e) {
                //出现异常
                DBIndex dbIndex = dragonHAConnection.getDBIndex();
                HAConnectionManager haConnectionManager = dragonHAConnection.getHAConnectionManager();
                DatasourceWrapper datasourceWrapper = haConnectionManager.getDatasourceWrapperByDbIndex(dbIndex);
                ExceptionSorter exceptionSorter = datasourceWrapper.getExceptionSorter();
                if (exceptionSorter.isExceptionFatal(e)) {//如果是致命异常
                    LOGGER.error("fatal exception,sqlstate:{},error code:{},sql:{}", e.getSQLState(), e.getErrorCode(), sql);
                    dragonHAConnection.getHAConnectionManager().invalid(dbIndex);
                    throw e;
                } else {
                    //不是致命异常,没有开启事务，其sql是查询，重试
                    if (failRetry()) {
                        LOGGER.warn("query failed for the " + (errorCount++) + "st try,sql state:{},error code:{},sql is:'{}'", e.getSQLState(), e.getErrorCode(), sql);
                        if (errorCount == maxRetryTimes) {
                            throw new SQLException("query failed after try 3 times,sql is:" + sql, e);
                        }
                        if(excludes==null){
                            excludes=new HashSet<DBIndex>();
                        }
                        excludes.add(dbIndex);
                        //选择一个新的数据源，创建connection，并且重新创建statement
                        Connection newConnection=dragonHAConnection.buildNewReadConnectionExclue(excludes);
                        if(newConnection==null){
                            LOGGER.error("no more datasource can be used to retry,have tried:{}", excludes);
                            throw e;
                        }
                        createRealStatement(newConnection);
                    } else {//如果开启了事务，或者是写操作，或者是致命异常，不重试
                        throw new SQLException("sql '" + sql + "' execute fail, no retry", e);
                    }
                }
            }
        }
        return isResultSet;
    }

    /**
     * 判断是否要使用sqlTypeCache，默认不使用cache，因为缓存的key是sql，对于Statament而言，sql的参数是直接是写在语句中的，无法命中的可能性大
     * Preparement应该对此进行覆盖，因为preparent对参数进行了剥离
     * @return
     */
    protected boolean useSqlTypeCache() {
        return false;
    }

    protected boolean failRetry() throws SQLException {
        return dragonHAConnection.getCurrentRealConnection().getAutoCommit() == true
                &&executeType!=EXECUTE_BATCH //batchexecute的情况下，不判断sql
               && SqlTypeUtil.isQuery(sql,useSqlTypeCache());
    }

    protected void setExecuteResult() throws SQLException {
        this.resultSet = realStatement.getResultSet();
        this.updateCount = realStatement.getUpdateCount();
        this.generatedKeys = realStatement.getGeneratedKeys();
    }

    protected boolean doExecuteByType() throws SQLException {
        boolean isResultSet=false;
        switch (executeType) {
            case EXECUTE_QUERY:
                realStatement.executeQuery(sql);
                isResultSet = true;
                break;
            case EXECUTE_UPDATE:
                realStatement.executeUpdate(sql);
                break;
            case EXECUTE_UPDATE_WITH_AUTOGENERATEDKEYS:
                realStatement.executeUpdate(sql, autoGeneratedKeys);
                break;
            case EXECUTE_UPDATE_WITH_COLUMNINDEXES:
                realStatement.executeUpdate(sql, columnIndexes);
                break;
            case EXECUTE_UPDATE_WITH_COLUMNNAMES:
                realStatement.executeUpdate(sql, columnNames);
                break;
            case EXECUTE:
                isResultSet = realStatement.execute(sql);
                break;
            case EXECUTE_WITH_AUTOGENERATEDKEYS:
                isResultSet = realStatement.execute(sql, autoGeneratedKeys);
                break;
            case EXECUTE_WITH_COLUMNINDEXES:
                isResultSet = realStatement.execute(sql, columnIndexes);
                break;
            case EXECUTE_WITH_COLUMNNAMES:
                isResultSet = realStatement.execute(sql, columnNames);
                break;
            case EXECUTE_BATCH:
                LOGGER.debug("execute batch....");
                batchExecuteResult= realStatement.executeBatch();
        }
        return isResultSet;
    }

    protected void setStatementParams() throws SQLException {
        if(queryTimeout!=null){
            realStatement.setQueryTimeout(queryTimeout);
        }
        if(fetchSize!=null){
            realStatement.setFetchSize(fetchSize);
        }
        if(fetchDirection!=null){
            realStatement.setFetchSize(fetchDirection);
        }
        if(poolable!=null){
            realStatement.setPoolable(poolable);
        }
        if(maxFieldSize!=null){
            realStatement.setMaxFieldSize(maxFieldSize);
        }
        if(maxRows!=null){
            realStatement.setMaxRows(maxRows);
        }
        if(enableEscapeProcessing!=null){
            realStatement.setEscapeProcessing(enableEscapeProcessing);
        }
    }

    //============================批处理操作，JDBC规范规定只能是更新语句，因此总是获取写connection==========

    /**
     * http://lavasoft.blog.51cto.com/62575/238651/
     * 优点：能够处理多种不同结构的sql语句
       缺点：不能预处理，执行效率较差。对于参数不同的同一条sql语句需要多次调用addBatch()
     * @return
     * @throws SQLException
     */
    @Override
    public int[] executeBatch() throws SQLException {
        this.executeType=EXECUTE_BATCH;
        doExecute();
        return batchExecuteResult;
    }
    @Override
    public void addBatch(String sql) throws SQLException {
        try {
            batchLock.lockInterruptibly();
            Connection currentRealConnection = dragonHAConnection.getCurrentRealConnection();
            if (currentRealConnection == null || currentRealConnection.isReadOnly()) {
                createRealStatement(dragonHAConnection.buildNewWriteConnection());
            }
            realStatement.addBatch(sql);
        } catch (InterruptedException e) {
            throw new SQLException(e);
        } finally {
            batchLock.unlock();
        }
    }
    @Override
    public void clearBatch() throws SQLException {
        if(realStatement!=null){
            realStatement.clearBatch();
        }
    }

    /**
     * JDBC规范规定，关闭statement的时候，需要关闭当前resultSet
     * @throws SQLException
     */
    @Override
    public void close() throws SQLException {
        if(resultSet!=null){
            resultSet.close();
            resultSet=null;
        }
        if(realStatement!=null){
            realStatement.close();
            realStatement=null;
        }
        isClosed = true;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return this.resultSet;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return this.updateCount;
    }

    /**
     * 如果执行的是存储过程的话，并且其中有多个查询语句，那么可能会返回多个ResultSet，JDBC规范规定，默认只需要返回第一个
     * 如果需要获取更多的ResultSet，通过getMoreResults来判断
     * @return
     * @throws SQLException
     */
    @Override
    public boolean getMoreResults() throws SQLException {
        return realStatement.getMoreResults();
    }
    @Override
    public boolean getMoreResults(int current) throws SQLException {
        return realStatement.getMoreResults(current);
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        this.fetchDirection=direction;
    }

    @Override
    public int getFetchDirection() throws SQLException {
        return this.fetchDirection;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        this.fetchSize=rows;
    }

    @Override
    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        return this.resultSetConcurrency;
    }

    @Override
    public int getResultSetType() throws SQLException {
        return resultSetType;
    }

    @Override
    public Connection getConnection() throws SQLException {
        return dragonHAConnection;
    }


    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        return generatedKeys;
    }
    @Override
    public int getMaxFieldSize() throws SQLException {
        return maxFieldSize;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        this.maxFieldSize=max;
    }

    @Override
    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        this.maxRows=max;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        this.enableEscapeProcessing=enable;
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        this.queryTimeout=seconds;
    }

    @Override
    public void cancel() throws SQLException {
        if(realStatement!=null){
            realStatement.cancel();
        }
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return realStatement.getWarnings();
    }

    @Override
    public void clearWarnings() throws SQLException {
        realStatement.clearWarnings();
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        realStatement.setCursorName(name);
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        return resultSetHoldability;
    }

    @Override
    public boolean isClosed() throws SQLException {
        return isClosed;
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        this.poolable=poolable;
    }

    @Override
    public boolean isPoolable() throws SQLException {
        return this.poolable;
    }
}
