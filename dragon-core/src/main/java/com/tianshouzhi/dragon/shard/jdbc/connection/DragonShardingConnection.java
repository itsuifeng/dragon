package com.tianshouzhi.dragon.shard.jdbc.connection;

import com.tianshouzhi.dragon.common.jdbc.connection.DragonConnection;
import com.tianshouzhi.dragon.shard.jdbc.datasource.DragonShardingConfig;
import com.tianshouzhi.dragon.shard.jdbc.statement.DragonShardingPrepareStatement;
import com.tianshouzhi.dragon.shard.jdbc.statement.DragonShardingStatement;

import java.sql.*;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by TIANSHOUZHI336 on 2016/12/11.
 */
public class DragonShardingConnection extends DragonConnection {
	private final DragonShardingConfig dragonShardingConfig;

	private Map<String, Set<Connection>> realConnectionMap = new ConcurrentHashMap<String, Set<Connection>>();

	public DragonShardingConnection(String username, String password, DragonShardingConfig dragonShardingConfig)
	      throws SQLException {
		super(username, password);
		if (dragonShardingConfig == null) {
			throw new SQLException("parameter 'shardingDataSource' can't be null");
		}
		this.dragonShardingConfig = dragonShardingConfig;
	}

	@Override
	public Statement createStatement() throws SQLException {
		checkClosed();
		DragonShardingStatement dragonShardingStatement = new DragonShardingStatement(this);
		statementList.add(dragonShardingStatement);
		return dragonShardingStatement;
	}

	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
		checkClosed();
		DragonShardingStatement dragonShardingStatement = new DragonShardingStatement(resultSetType, resultSetConcurrency,
		      this);
		statementList.add(dragonShardingStatement);
		return dragonShardingStatement;
	}

	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
	      throws SQLException {
		checkClosed();
		DragonShardingStatement dragonShardingStatement = new DragonShardingStatement(resultSetType, resultSetConcurrency,
		      resultSetHoldability, this);
		statementList.add(dragonShardingStatement);
		return dragonShardingStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		checkClosed();
		DragonShardingPrepareStatement prepareStatement = new DragonShardingPrepareStatement(sql, this);
		statementList.add(prepareStatement);
		return prepareStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
	      throws SQLException {
		checkClosed();
		DragonShardingPrepareStatement prepareStatement = new DragonShardingPrepareStatement(sql, resultSetType,
		      resultSetConcurrency, this);
		statementList.add(prepareStatement);
		return prepareStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
	      int resultSetHoldability) throws SQLException {
		checkClosed();
		DragonShardingPrepareStatement prepareStatement = new DragonShardingPrepareStatement(sql, resultSetType,
		      resultSetConcurrency, resultSetHoldability, this);
		statementList.add(prepareStatement);
		return prepareStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		checkClosed();
		DragonShardingPrepareStatement prepareStatement = new DragonShardingPrepareStatement(sql, autoGeneratedKeys,
		      this);
		statementList.add(prepareStatement);
		return prepareStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
		checkClosed();
		DragonShardingPrepareStatement prepareStatement = new DragonShardingPrepareStatement(sql, columnIndexes, this);
		statementList.add(prepareStatement);
		return prepareStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
		checkClosed();
		DragonShardingPrepareStatement prepareStatement = new DragonShardingPrepareStatement(sql, columnNames, this);
		statementList.add(prepareStatement);
		return prepareStatement;
	}

	@Override
	public CallableStatement prepareCall(String sql) throws SQLException {
		throw new UnsupportedOperationException("prepareCall");
	}

	@Override
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		throw new UnsupportedOperationException("prepareCall");
	}

	@Override
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
	      int resultSetHoldability) throws SQLException {
		throw new UnsupportedOperationException("prepareCall");
	}

	@Override
	public String nativeSQL(String sql) throws SQLException {
		throw new UnsupportedOperationException("nativeSQL");
	}

	@Override
	public void commit() throws SQLException {
		checkClosed();
		if (autoCommit) {
			throw new SQLException("This method should be used only when auto-commit mode has been disabled");
		}
		for (Set<Connection> connections : realConnectionMap.values()) {
			for (Connection connection : connections) {
				if (!connection.getAutoCommit()) {
					connection.commit();
				}
			}
		}
	}

	@Override
	public void rollback() throws SQLException {
		checkClosed();
		if (autoCommit) {
			throw new SQLException("This method should be used only when auto-commit mode has been disabled");
		}
		for (Set<Connection> connections : realConnectionMap.values()) {
			for (Connection connection : connections) {
				if (!connection.getAutoCommit()) {
					connection.rollback();
				}
			}
		}
	}

	@Override
	public void close() throws SQLException {
		for (Set<Connection> connections : realConnectionMap.values()) {
			for (Connection connection : connections) {
				if (!connection.getAutoCommit()) {
					connection.close();
				}
			}
		}
	}

	@Override
	public DatabaseMetaData getMetaData() throws SQLException {

		return null;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {

	}

	@Override
	public Savepoint setSavepoint() throws SQLException {
		throw new UnsupportedOperationException("setSavepoint");
	}

	@Override
	public Savepoint setSavepoint(String name) throws SQLException {
		throw new UnsupportedOperationException("setSavepoint(String haDSName)");
	}

	@Override
	public void rollback(Savepoint savepoint) throws SQLException {
		throw new UnsupportedOperationException("rollback");
	}

	@Override
	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		throw new UnsupportedOperationException("releaseSavepoint");
	}

	@Override
	public Clob createClob() throws SQLException {
		// 真实连接还没有，不知道到哪个库创建Clob
		throw new UnsupportedOperationException("createClob");
	}

	@Override
	public Blob createBlob() throws SQLException {
		throw new UnsupportedOperationException("createBlob");
	}

	@Override
	public NClob createNClob() throws SQLException {
		throw new UnsupportedOperationException("createNClob");
	}

	@Override
	public SQLXML createSQLXML() throws SQLException {
		throw new UnsupportedOperationException("SQLXML");
	}

	@Override
	public boolean isValid(int timeout) throws SQLException {
		return false;
	}

	@Override
	public String getClientInfo(String name) throws SQLException {
		return null;
	}

	@Override
	public Properties getClientInfo() throws SQLException {
		return null;
	}

	@Override
	public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
		throw new UnsupportedOperationException("createArrayOf");
	}

	@Override
	public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
		throw new UnsupportedOperationException("createStruct");
	}

	public DragonShardingConfig getDragonShardingConfig() {
		return dragonShardingConfig;
	}

	public Map<String, Set<Connection>> getRealConnectionMap() {
		return realConnectionMap;
	}
}
